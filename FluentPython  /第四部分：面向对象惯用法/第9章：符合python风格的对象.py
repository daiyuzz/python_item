# 9.1 对象的表现形式


"""
repr() 以便于开发者理解的方式返回对象的字符串标识形式

str() 以便于用户理解的方式返回对象的字符串表示形式




"""

# 9.4 classmethod 和staticmethod

"""
classmethod 定义操作类，而不是操作实例的方法。classmethod 改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。
classmethod 最常见的用途是定义备选构造方法


staticmethod 装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。

"""


class Demo:
    @classmethod
    def klassmeth(*args):
        return args

    @staticmethod
    def statmeth(*args):
        return args


print(Demo.klassmeth())  # 不管怎样调用 Demo.klassmeth ,它的第一个参数始终是 Demo类
# (<class '__main__.Demo'>,)

print(Demo.klassmeth('spam'))
# (<class '__main__.Demo'>, 'spam')

print(Demo.statmeth())  # Demo.statemeth 的行为与普通的函数类似
# ()

print(Demo.statmeth('spam'))
# ('spam',)


"""
classmethod 装饰器非常有用，但是我从未见过不得不用
staticmethod 的情况。如果想定义不需要与类交互的函数，那
么在模块中定义就好了。有时，函数虽然从不处理类，但是函数的
功能与类紧密相关，因此想把它放在近处。即便如此，在同一模块
中的类前面或后面定义函数也就行了

"""

# 9.7 Python 的私有属性和“受保护的”属性

"""
Python 不能像 Java 那样使用private 装饰符创建私有属性，但是，python有个简单的机制，能避免子类意外覆盖“私有”属性。


举个例子。有人编写了一个名为 Dog 的类，这个类的内部用到了 mood
实例属性，但是没有将其开放。现在，你创建了 Dog 类的子
类：Beagle。如果你在毫不知情的情况下又创建了名为 mood 的实例
属性，那么在继承的方法中就会把 Dog 类的 mood 属性覆盖掉。这是个
难以调试的问题。
为了避免这种情况，如果以 __mood 的形式（两个前导下划线，尾部没
有或最多有一个下划线）命名实例属性，Python 会把属性名存入实例的
__dict__ 属性中，而且会在前面加上一个下划线和类名。因此，对
Dog 类来说，__mood 会变成 _Dog__mood；对 Beagle 类来说，会
变成 _Beagle__mood。这个语言特性叫名称改写（name mangling）。


"""

# 9.8 使用 __slots__ 类属性节省空间

"""
默认情况下，Python 在各个实例中名为 __dict__ 的字典里存储实例属
性。如 3.9.3 节所述，为了使用底层的散列表提升访问速度，字典会消
耗大量内存。如果要处理数百万个属性不多的实例，通过 __slots__
类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而
不用字典



继承自超类的 __slits__ 属性没有效果。Python 只会使用各个类中定义的 __slots__ 属性


定义 __slots__ 的方式是，创建一个类属性，使用 __slots__ 这个 名字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表 示各个实例属性。

"""


class Vector2d:
    __slots__ = ('__x', '__y')

    typecode = 'd'

    # ....

"""
在类中定义 __slots__ 属性的目的是告诉解释器：“这个类中的所有
实例属性都在这儿了！”这样，Python 会在各个实例中使用类似元组的
结构存储实例变量，从而避免使用消耗内存的 __dict__ 属性。如果
有数百万个实例同时活动，这样做能节省大量内存



总之，如果使用得当，__slots__ 能显著节省内存，不过有几点要注 意。 
- 每个子类都要定义 __slots__ 属性，因为解释器会忽略继承的 __slots__ 属性。 
- 实例只能拥有 __slots__ 中列出的属性，除非把 '__dict__' 加入 __slots__ 中（这样做就失去了节省内存的功效）。 
- 如果不把 '__weakref__' 加入 __slots__，实例就不能作为弱 引用的目标。

"""


# 9.9 覆盖类属性


# 9.10 小结

"""
符合 Python 风格的对象应该正好符合所需，而不是堆砌语言特性

- 所有用于获取字符串和字节序列表示形式的方法：__repr__、__str__、__format__ 和 __bytes__。
- 把对象转换成数字的几个方法：__abs__、__bool__和__hash__。
- 用于测试字节序列转换和支持散列（连同 __hash__ 方法）的__eq__ 运算符



"""
